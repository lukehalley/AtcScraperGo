package main

import (
	"atcscraper/src/data"
	"atcscraper/src/db/graphql/bitquery/querys"
	graphql_helpers "atcscraper/src/db/graphql/helpers"
	insert "atcscraper/src/db/mysql/insert"
	query "atcscraper/src/db/mysql/query"
	"atcscraper/src/io"
	"atcscraper/src/types/bitquery"
	"atcscraper/src/types/web3"
	dex "atcscraper/src/web3"
	"context"
	"fmt"
	"github.com/Khan/genqlient/graphql"
	"github.com/projectdiscovery/ratelimit"
	"log"
	"os"
	"strconv"
	"time"
)

func main() {

	// Env Vars
	LazyMode := false
	CacheMode, _ := strconv.ParseBool(os.Getenv("CACHE_MODE"))

	////////////////////////////////////////////////////
	// Init Vars
	////////////////////////////////////////////////////

	// List For Storing Network Dexs
	var ProcessedNetworkDexs []bitquery.Dex
	var DexsWithPairs []bitquery.Dex

	// Set Our Beginning Time For Timeframe
	FromTime := graphql_helpers.GenerateGraphQLTimestamp("2022-12-01T01:00:00Z")

	// Set Our NetworkObject
	NumberOfDexsToCollect := 5

	////////////////////////////////////////////////////
	// Setup HTTP Client For API Calls
	////////////////////////////////////////////////////

	// Get The Bitquery API Key
	BitqueryApiKey := "BQY6Sk2AvIsRy20KFTdNXuiSvDr9DEtR"

	// Create Query Client
	HTTPClient := graphql_helpers.CreateHTTPClientWithAuth(BitqueryApiKey)
	QueryClient := graphql.NewClient("https://graphql.bitquery.io", &HTTPClient)
	QueryContext := context.Background()

	////////////////////////////////////////////////////
	// Get Bitquery Account Details
	////////////////////////////////////////////////////

	graphql_helpers.LogSeparator(false)

	// Get Out Current Bitquery Account Details
	StartAccountQuery, QueryError := atcqueries.GetBitQueryAccountDetails(QueryContext, QueryClient, BitqueryApiKey)
	StartingBitQueryPoints, _ := strconv.Atoi(StartAccountQuery.Utilities.ActivePeriod.PointsRemaining)

	// Catch Query Errors
	if QueryError != nil {
		log.Panicln("Error Querying Bitquery Account:", QueryError)
	} else {
		log.Printf("Bitquery Points Balance: %v", StartingBitQueryPoints)
	}

	graphql_helpers.LogSeparator(true)

	if !CacheMode {

		////////////////////////////////////////////////////
		// Collect Networks + Stablecoins
		////////////////////////////////////////////////////

		Networks := data.GetNetworkList()

		if LazyMode {
			Networks = Networks[0:1]
		}

		////////////////////////////////////////////////////
		// Get All UnprocessedNetworkDexs On Each NetworkObject
		////////////////////////////////////////////////////

		// Start Log
		graphql_helpers.LogSeparator(false)
		log.Printf("Collecting Dex For %v Network(s)", len(Networks))
		graphql_helpers.LogSeparator(false)

		// Kick Off The Function Which Gets The Dexs For Each Network
		var UnprocessedNetworkDexs [][]bitquery.Dex
		DexCollectionRateLimit := ratelimit.New(context.Background(), 1, 60*time.Second)
		for _, Network := range Networks {
			DexCollectionRateLimit.Take()
			CurrentNetworkDexs := data.CollectDexsForNetwork(Network, NumberOfDexsToCollect, FromTime, QueryContext, QueryClient)
			UnprocessedNetworkDexs = append(UnprocessedNetworkDexs, CurrentNetworkDexs)
		}

		graphql_helpers.LogSeparator(false)

		// Get Non-Null Dexs
		for _, NetworkDex := range UnprocessedNetworkDexs {
			CurrentNetwork := data.TitleCaseString(NetworkDex[0].Network.Name)
			NetworkDexCount := 0
			for _, Dex := range NetworkDex {
				if Dex.RouterAddress != "" && Dex.FactoryAddress != "" {
					NetworkDexCount = NetworkDexCount + 1
					ProcessedNetworkDexs = append(ProcessedNetworkDexs, Dex)
				}
			}
			log.Printf("[%v] %v Dex(s)", CurrentNetwork, NetworkDexCount)
		}

		// Result Log
		graphql_helpers.LogSeparator(false)
		log.Printf("Collected %v Dex(s) Across %v Network(s)", len(ProcessedNetworkDexs), len(Networks))
		graphql_helpers.LogSeparator(true)

		// Sleep For 1 Min For Rate Limit
		time.Sleep(60 * time.Second)

		////////////////////////////////////////////////////
		// Get Dex Pairs
		////////////////////////////////////////////////////

		// Pair Log
		graphql_helpers.LogSeparator(false)
		log.Printf("Collecting Pairs For %v Dexs(s)", len(ProcessedNetworkDexs))
		graphql_helpers.LogSeparator(false)

		// List Of Dex Pair Transactions
		var AllPairTransactions [][]web3.PairTransactions

		// For Each Dex - Get All Pairs Matched With Selected Stablecoins
		PairCollectionRateLimit := ratelimit.New(context.Background(), 10, 60*time.Second)
		for _, Dex := range ProcessedNetworkDexs {
			PairCollectionRateLimit.Take()
			var PairTransactions []web3.PairTransactions
			Dex.Pairs, PairTransactions = data.CollectStablecoinPairsForDex(Dex, 1000, FromTime, QueryContext, QueryClient)
			if len(Dex.Pairs) > 0 {
				DexsWithPairs = append(DexsWithPairs, Dex)
				AllPairTransactions = append(AllPairTransactions, PairTransactions)
				log.Printf("Collected %v Pairs(s) For Dex %v On Network %v", len(Dex.Pairs), Dex.FactoryAddress, Dex.Network.Name)
			}
		}

		graphql_helpers.LogSeparator(true)

		////////////////////////////////////////////////////
		// Save Data To Local Cache
		////////////////////////////////////////////////////

		// Cache Log
		graphql_helpers.LogSeparator(false)
		log.Printf("Saving Data To Local Cache...")
		graphql_helpers.LogSeparator(false)

		// Save Data To Local File
		io.SaveDataToCache(DexsWithPairs, "DexCache")
		io.SaveDataToCache(AllPairTransactions, "AllPairTransactions")

		// Finish Log
		log.Printf("Data Saved")
		graphql_helpers.LogSeparator(true)

		////////////////////////////////////////////////////
		// Calculate How Many Bitquery Points We Used
		////////////////////////////////////////////////////

		graphql_helpers.LogSeparator(false)

		// Get Out Current Bitquery Account Details
		EndAccountQuery, EndQueryError := atcqueries.GetBitQueryAccountDetails(QueryContext, QueryClient, BitqueryApiKey)
		EndingBitQueryPoints, _ := strconv.Atoi(EndAccountQuery.Utilities.ActivePeriod.PointsRemaining)
		UsedBitQueryPoints := StartingBitQueryPoints - EndingBitQueryPoints

		// Catch Query Errors
		if EndQueryError != nil {
			log.Panicln("Error Querying Bitquery Account:", EndQueryError)
		} else {
			log.Printf("New Bitquery Points Balance: %v", StartingBitQueryPoints)
			log.Printf("Final BitQuery Points Usage: %v", UsedBitQueryPoints)
		}

		graphql_helpers.LogSeparator(true)

	} else {

		////////////////////////////////////////////////////
		// Load Local Cache File
		////////////////////////////////////////////////////

		// Read Local Cache
		DexsWithPairs = io.ReadCacheFile("DexCache")

		graphql_helpers.LogSeparator(false)
		log.Printf("Read %v Dex(s) From Cache", len(DexsWithPairs))
		graphql_helpers.LogSeparator(true)

	}

	////////////////////////////////////////////////////
	// Write Tokens To DB
	////////////////////////////////////////////////////

	graphql_helpers.LogSeparator(false)
	log.Printf("Inserting Collected Pairs To DB")
	graphql_helpers.LogSeparator(false)

	// Group Networks With Their Stablecoins
	for _, Dex := range DexsWithPairs {
		for _, DexPair := range Dex.Pairs {

			////////////////////////////////////////////////////
			// Add or Read Dex
			////////////////////////////////////////////////////

			// Check If The Dex Is Already Stored
			RetrievedDexDBId := query.GetDexFromDB(Dex.RouterAddress, Dex.FactoryAddress, Dex.Network.NetworkId)
			DexDBId := int64(0)

			// If The Dex Not Already Stored - Add It To The DB
			if len(RetrievedDexDBId) < 1 {
				// Add The Current Dex To The DB
				DexDBId = insert.AddDexToDB(Dex.RouterAddress, Dex.FactoryAddress, Dex.Network.NetworkId)
			} else {
				DexDBId = int64(RetrievedDexDBId[0].DexId)
			}

			////////////////////////////////////////////////////
			// Add or Read Base Currency
			////////////////////////////////////////////////////

			// Check If The Base Currency Token Is Already Stored
			RetrievedDBBaseCurrency := query.GetTokenFromDB(Dex.Network.NetworkId, DexPair.BaseCurrency.Address, DexPair.BaseCurrency.Symbol)
			BaseCurrencyDBId := int64(0)

			// Add The Base Token To The DB If It's Not Stored
			if len(RetrievedDBBaseCurrency) < 1 {
				BaseCurrencyDBId = insert.AddTokenToDB(DexPair.BaseCurrency.Symbol, DexPair.BaseCurrency.Address, DexPair.BaseCurrency.Decimals, 0, Dex.Network.NetworkId)
			} else {
				BaseCurrencyDBId = int64(RetrievedDBBaseCurrency[0].TokenId)
			}

			////////////////////////////////////////////////////
			// Add or Read Quote Currency
			////////////////////////////////////////////////////

			// Query The DB For The DB ID Of Pairs RetrievedDBStablecoinDB
			RetrievedDBStablecoinDB := query.GetTokenFromDB(Dex.Network.NetworkId, DexPair.QuoteCurrency.Address, DexPair.QuoteCurrency.Symbol)
			StablecoinDBId := int64(0)

			// Add The Quote Token To The DB If It's Not Stored
			if len(RetrievedDBStablecoinDB) < 1 {
				StablecoinDBId = insert.AddTokenToDB(DexPair.QuoteCurrency.Symbol, DexPair.QuoteCurrency.Address, DexPair.QuoteCurrency.Decimals, 1, Dex.Network.NetworkId)
			} else {
				StablecoinDBId = int64(RetrievedDBStablecoinDB[0].TokenId)
			}

			////////////////////////////////////////////////////
			// Add or Read Pair
			////////////////////////////////////////////////////

			// Build The Pairs Name
			PairName := fmt.Sprintf("%v/%v", DexPair.BaseCurrency.Symbol, DexPair.QuoteCurrency.Symbol)

			// Get The Address Of The Pair
			PairAddress := dex.GetPairAddress(DexPair.BaseCurrency.Address, DexPair.QuoteCurrency.Address, Dex.FactoryAddress, Dex.Network.ChainRpc)

			// Check If The Pair Is Already Stored
			RetrievedDBPair := query.GetPairFromDB(PairAddress, Dex.Network.NetworkId)

			// Add The Pair To The DB If It's Not Stored
			if len(RetrievedDBPair) < 1 {

				// Insert The Pair Into The DB
				insert.AddPairToDB(BaseCurrencyDBId, StablecoinDBId, Dex.Network.NetworkId, DexDBId, PairName, PairAddress)

				log.Printf("Added: %v [%v]", PairName, Dex.Network.Name)

			} else {

				log.Printf("Already Present: %v [%v]", PairName, Dex.Network.Name)

			}

		}
	}

	graphql_helpers.LogSeparator(true)

}
